<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Red-Black Tree | Four-Square behind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="PrefaceBST(Binary Search Tree) RetrievalRetrieving an element from BST requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for">
<meta property="og:type" content="article">
<meta property="og:title" content="Red-Black Tree">
<meta property="og:url" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/index.html">
<meta property="og:site_name" content="Four-Square behind">
<meta property="og:description" content="PrefaceBST(Binary Search Tree) RetrievalRetrieving an element from BST requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_1.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_1.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_example_1.png">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_example_1.png">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_invertible_rotation.png">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_1.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_2.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_3.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_4.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_5.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_6.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_7.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_1.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_1_full.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_2.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_2_full.jpg">
<meta property="og:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_3_full.jpg">
<meta property="og:updated_time" content="2016-11-29T19:26:06.429Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Red-Black Tree">
<meta name="twitter:description" content="PrefaceBST(Binary Search Tree) RetrievalRetrieving an element from BST requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for">
<meta name="twitter:image" content="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Four-Square behind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Four-Square behind</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://foursquarebehind.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Red-Black-Tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archive/2016/11/16/Red-Black-Tree/" class="article-date">
  <time datetime="2016-11-16T21:04:28.000Z" itemprop="datePublished">2016-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Red-Black Tree
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><h5 id="BST-Binary-Search-Tree-Retrieval"><a href="#BST-Binary-Search-Tree-Retrieval" class="headerlink" title="BST(Binary Search Tree) Retrieval"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>
<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>
<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>
<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>
<hr>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either <strong>RED</strong> or <strong>BLACK</strong> and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>
<p><a name="Properties"></a></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ol>
<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>
<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>
<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>
<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>
<li>The root is always <strong>BLACK</strong>;</li>
</ol>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg" alt="Figure 1 Red-Black Tree" title="Figure 1 Red-Black Tree">
<hr>
<h1 id="Application-of-Red-Black-Tree"><a href="#Application-of-Red-Black-Tree" class="headerlink" title="Application of Red-Black Tree"></a>Application of Red-Black Tree</h1><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>
<hr>
<table>
<thead>
<tr>
<th style="text-align:left"><strong> Basis </strong></th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$h$</td>
<td style="text-align:left">Height of the tree;</td>
</tr>
<tr>
<td style="text-align:left">$h(x)$</td>
<td style="text-align:left">Height of the node $x$;</td>
</tr>
<tr>
<td style="text-align:left">$bh$</td>
<td style="text-align:left"><strong>Black-Height</strong> of the tree;</td>
</tr>
<tr>
<td style="text-align:left">$bh(x)$</td>
<td style="text-align:left"><strong>Black-Height</strong> of the node $x$;</td>
</tr>
<tr>
<td style="text-align:left">$n$</td>
<td style="text-align:left">Number of nodes in the tree;</td>
</tr>
<tr>
<td style="text-align:left">$n(x)$</td>
<td style="text-align:left">Number of the nodes of the node $x$;</td>
</tr>
</tbody>
</table>
<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 4<sup>th</sup> property above as each <strong>RED</strong> node strictly requires <strong>BLACK</strong> children</em>)</p>
<hr>
<h1 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h1><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>
<h1 id="Proof-by-induction"><a href="#Proof-by-induction" class="headerlink" title="Proof by induction"></a>Proof by induction</h1><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>
<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of <strong>BLACK</strong> nodes is <strong>Black-Height</strong> of the node $x$, or $x$’s <strong>Black-Height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>
<p><strong>Point 1</strong>: According to the 3<sup>rd</sup> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sup>th</sup> <strong>Red-Black Tree</strong> properties, “Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes”, we can say starting from the node x to leaf node, the number of <strong>BLACK</strong> nodes &gt;= the number the <strong>RED</strong> nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>
<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>
<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>
<hr>
<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>
<p><strong>Induction step</strong>:</p>
<ol>
<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>Black-Height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>
<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>
<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>
<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left"><strong> Thus </strong></th>
<th style="text-align:left">&nbsp;</th>
<th style="text-align:left">&nbsp;</th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$n$</td>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">$2^{bh} - 1$</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">$n$</td>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">$2^{h/2} - 1$</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">$log_2(n + 1)$</td>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">$h/2$</td>
<td style="text-align:left">&nbsp;</td>
</tr>
<tr>
<td style="text-align:left">$h$</td>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">$2 * log_2(n + 1)$</td>
<td style="text-align:left">&nbsp;</td>
</tr>
</tbody>
</table>
<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>
<p><strong>Corollary</strong>:<br>All operations of a <strong>Red-Black Tree</strong> take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();<br>Insert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;</p>
<hr>
<h1 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h1><p>Every node of <strong>Red-Black Tree</strong> has $5$ attributes:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> t_red_black_node &#123;</div><div class="line">    <span class="keyword">enum</span> &#123; </div><div class="line">        RED, BLACK </div><div class="line">    &#125; color;</div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line">    <span class="keyword">struct</span> t_red_black_node *left;</div><div class="line">    <span class="keyword">struct</span> t_red_black_node *right;</div><div class="line">    <span class="keyword">struct</span> t_red_black_node *parent;</div><div class="line">	<span class="keyword">void</span> *value;</div><div class="line">	<span class="keyword">int</span> numLeft;      <span class="comment">//optional</span></div><div class="line">	<span class="keyword">int</span> numRight;     <span class="comment">//optional</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>A <strong>Red-Black Tree</strong> node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated.<br>Of course we can add more variables like the count of its children nodes according to the requirements.</p>
<hr>
<h1 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h1><p>How does <strong>inserting</strong> or <strong>deleting</strong> nodes affect a <strong>Red-Black Tree</strong>? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like <strong>inserting</strong> or <strong>deleting</strong>, the <strong>Red-Black Tree</strong> is continue to keep the its properties and balance.</p>
<p><strong>Rotation</strong> is a basic operation for changing <strong>Black-Red Tree</strong> structure, it’s a binary operation, between a <strong>parent</strong> node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).</p>
<p>There are two types of rotations: <strong>Left Rotation</strong> and <strong>Right Rotation</strong>.<br><strong>Left Rotation</strong> swaps the <strong>parent</strong> node with its right child,<br><strong>Right Rotation</strong> swaps the <strong>parent</strong> node with its left child. </p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Left Rotation</strong></th>
<th>&nbsp;</th>
<th style="text-align:center"><strong>Right Rotation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_1.jpg" alt=" Left Rotation" title=" Left Rotation"></td>
<td>&nbsp;</td>
<td style="text-align:center"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_1.jpg" alt=" Right Rotation" title=" Right Rotation"></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="Left-Rotation"><a href="#Left-Rotation" class="headerlink" title="Left Rotation"></a>Left Rotation</h3><p>Here are the steps involved in for <strong>Left Rotation</strong> (for <strong>Right Rotation</strong> just change “Left” to “Right” below):</p>
<p>When do the <strong>Left Rotation</strong> on a <strong>pivot</strong>, assume its right child is not <strong>NIL[T]</strong>. <strong>pivot</strong> is a left child of any nodes but not <strong>NIL[T]</strong><br><strong>Left Rotation</strong> is based on the axis between the <strong>pivot</strong> node and <strong>y</strong> node, the steps are:</p>
<ol>
<li>Let node <strong>y</strong> be the <strong>parent</strong> of the <strong>pivot</strong> node;</li>
<li>Let the <strong>pivot</strong> node be the left child of node <strong>y</strong>;</li>
<li>Let the left child of node <strong>y</strong> be the rigth child of the <strong>pivot</strong> node;</li>
</ol>
<p>The C++ code for <strong>Left Rotation</strong> is below(use <strong>x</strong> as the <strong>pivot</strong> node which is mentioned above):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_Rotate</span><span class="params">(Node **T,Node * x)</span> </span>&#123;   <span class="comment">// T: tree, x: pivot node</span></div><div class="line">  Node *y = x-&gt;right;  </div><div class="line">   </div><div class="line">  x-&gt;right = y-&gt;left;                   <span class="comment">// Turn y's left subtree into x's right subtree</span></div><div class="line">  <span class="keyword">if</span> (y-&gt;left != T_NIL)                 <span class="comment">// If y-&gt;left is not null, set x as the parent of y's left child</span></div><div class="line">      y-&gt;left-&gt;p = x;  </div><div class="line">  y-&gt;p = x-&gt;p;                          <span class="comment">// Link x's parent to y</span></div><div class="line">  <span class="keyword">if</span>(x-&gt;p == T_NIL)                     <span class="comment">// Means x is root, so its parent is nil</span></div><div class="line">     *T = y;                            <span class="comment">// Case 1： first see whether we're at the root, set root as y if we are</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;p-&gt;left)             <span class="comment">// Case 2： x was on the left of its parent</span></div><div class="line">     x-&gt;p-&gt;left = y;                    <span class="comment">//         set y as the left child of x's parent</span></div><div class="line">  <span class="keyword">else</span>                                  <span class="comment">// Case 3: x must have been on the right</span></div><div class="line">     x-&gt;p-&gt;right = y;                   <span class="comment">//         so set y as the right child of x's parent;</span></div><div class="line">  y-&gt;left = x;                          <span class="comment">// Set x as y's left child </span></div><div class="line">  x-&gt;p = y;                             <span class="comment">// Set y as x's parent;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>So as the figure below, <strong>Left Rotation</strong> on node <strong>X</strong> means make node <strong>X</strong>‘s right child as node <strong>X</strong>‘s <strong>parent</strong> node, that is make node <strong>X</strong> as a left child node (node <strong>X</strong> becomes the left child of node <strong>Z</strong>)!<br>So <strong>Left</strong> means the <strong>Rotated</strong> node will be turned to a left child node.<br><img src="/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_example_1.png" alt=" Left Rotation" title=" Left Rotation"> </p>
<hr>
<h3 id="Right-Rotation"><a href="#Right-Rotation" class="headerlink" title="Right Rotation"></a>Right Rotation</h3><p>The C++ code for <strong>Right Rotation</strong> is below(use <strong>y</strong> as the <strong>pivot</strong> node which is mentioned above):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_Rotate</span><span class="params">(Node **T,Node *y)</span> </span>&#123;   <span class="comment">// T: tree, y: pivot node</span></div><div class="line">  Node *x = y-&gt;left;  </div><div class="line">   </div><div class="line">  y-&gt;left = x-&gt;right;                  <span class="comment">// Turn x's right subtree into y's left subtree</span></div><div class="line">  <span class="keyword">if</span> (x-&gt;right != T_NIL)               <span class="comment">// If x-&gt;right is not null, set y as the parent of x's right child</span></div><div class="line">      x-&gt;right-&gt;p = y;  </div><div class="line">  x-&gt;p = y-&gt;p;                         <span class="comment">// Link y's parent to x</span></div><div class="line">  <span class="keyword">if</span>(y-&gt;p == T_NIL)                    <span class="comment">// Means y is root, so its parent is nil</span></div><div class="line">     *T = x;                           <span class="comment">// Case 1： first see whether we're at the root, set root as x if we are</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;p-&gt;left)            <span class="comment">// Case 2： y was on the left of its parent</span></div><div class="line">     y-&gt;p-&gt;left = x;                   <span class="comment">//         set x as the left child of y's parent</span></div><div class="line">  <span class="keyword">else</span>                                 <span class="comment">// Case 3: y must have been on the right</span></div><div class="line">     y-&gt;p-&gt;right = x;                  <span class="comment">//         so set x as the right child of y's parent</span></div><div class="line">  x-&gt;right = y;                        <span class="comment">// Set y as x's right child </span></div><div class="line">  y-&gt;p = x;                            <span class="comment">// Set x as y's parent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>So as the figure below, <strong>Reft Rotation</strong> on <strong>x</strong> means make <strong>x</strong>‘s left child as <strong>x</strong>‘s <strong>parent</strong>, that is make <strong>x</strong> as a right child node (<strong>x</strong> becomes the right child of <strong>y</strong>)!<br>So <strong>Right</strong> means the <strong>Rotated</strong> node will be turned to a right child node.<br><img src="/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_example_1.png" alt=" Right Rotation" title=" Right Rotation"> </p>
<hr>
<p>So <strong>Left Rotation</strong> and <strong>Right Rotation</strong> are a pair of <strong>invertible</strong> operations.<br><img src="/archive/2016/11/16/Red-Black-Tree/rbt_invertible_rotation.png" alt=" Invertible Operations between Left/Right Rotation" title=" Invertible Operations between Left/Right Rotation"> </p>
<hr>
<h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><h3 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h3><table>
<thead>
<tr>
<th style="text-align:left"><strong>An Example for Insertion</strong></th>
<th style="text-align:right">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Color this tree</strong></td>
<td style="text-align:right"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_1.jpg" alt="Step 1 " title="Step 1 "></td>
</tr>
<tr>
<td style="text-align:left"><strong>Insert 8</strong><br>Where does it go?<br>What color shoult it be?</td>
<td style="text-align:right"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_2.jpg" alt="Step 2 " title="Step 2 "></td>
</tr>
<tr>
<td style="text-align:left"><strong>Insert 8</strong><br>Color the inserted node as <strong>RED</strong></td>
<td style="text-align:right"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_3.jpg" alt="Step 3 " title="Step 3 "></td>
</tr>
<tr>
<td style="text-align:left"><strong>Insert 11</strong><br>Where does it go?<br>What color shoult it be?<br>Can’t be <strong>RED</strong>!(break <a href="#Properties">property</a> #4)<br>Can’t be <strong>BLACK</strong>!(break <a href="#Properties">property</a> #3)</td>
<td style="text-align:right"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_4.jpg" alt="Step 4 " title="Step 4 "></td>
</tr>
<tr>
<td style="text-align:left"><strong>Insert 11</strong><br>Where does it go?<br>Solution: recolor the tree</td>
<td style="text-align:right"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_5.jpg" alt="Step 5 " title="Step 5 "></td>
</tr>
<tr>
<td style="text-align:left"><strong>Insert 10</strong><br>Where does it go?<br>What color shoult it be?<br><br><strong>Answer</strong>: no color! Tree is too imbalanced!<br>Must change tree structure to allow recoloring<br><strong>Goal</strong>: Restructure tree in $O(log_2(n))$ time</td>
<td style="text-align:right"><img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_6.jpg" alt="Step 6 " title="Step 6 "></td>
</tr>
</tbody>
</table>
<p>Based on the above example, the <strong>Red-Black Tree Insertion operation</strong> is to do a regular BST insertion, then do the operations (recolor or rotate) to make the new tree satisfy with all of the <strong>Red-Black Tree</strong> <a href="#Properties">properties</a>.<br>A special case is required for an empty tree. If the tree is empty, replace it with a single <strong>BLACK</strong> node containing the inserted value. This ensures that the root property is satisfied.</p>
<p>So assume we are trying to insert one new node <strong>x</strong> to <strong>T</strong> (a nonempty <strong>Red-Black Tree</strong>)</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Steps</strong>:</th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>1</strong>:</td>
<td style="text-align:left">Use the BST insert algorithm to insert <strong>x</strong> to <strong>T</strong> (<strong><em>Note: every insertion take places at a leaf)</em></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>2</strong>:</td>
<td style="text-align:left">Color the node <strong>x</strong> <strong>RED</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong>:</td>
<td style="text-align:left">Restore <strong>Red-Black Tree</strong> <a href="#Properties">properties</a> by <strong>recolor</strong> or <strong>rotate</strong> operations (if necessary)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">&nbsp;</th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><em>Question</em></strong>:</td>
<td style="text-align:left">At <strong>Step 2</strong>, why color the new inserted node <strong>x</strong> as <strong>RED</strong>?</td>
</tr>
<tr>
<td style="text-align:left"><strong><em>Answer</em></strong>:</td>
<td style="text-align:left">Recall the <strong>Red-Black Tree</strong> <a href="#Properties">properties</a>, color the new inserted node <strong>x</strong> as <strong>RED</strong> won’t violate the <a href="#Properties">property</a> #3, so the <strong>Black-Height</strong> will be same as before the insertion</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">which means the less cases we have to handle to keep maintaining the <strong>Red-Black Tree</strong> <a href="#Properties">properties</a></td>
</tr>
</tbody>
</table>
<p>Back to the step #6 in the example above, after insert <strong>10</strong> into the <strong>Red-Black Tree</strong>, first based on the regular BST insert algorithm to find the proper location, where is the left child of node <strong>11</strong>, then we should color the node <strong>10</strong> as <strong>RED</strong>, so now we get a tree like below:</p>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_7.jpg" alt="Insert 10 and then color the new inserted node as RED " title="Insert 10 and then color the new inserted node as RED "> 
<table>
<thead>
<tr>
<th style="text-align:left"><strong><em>Properties again</em></strong></th>
<th style="text-align:center">&nbsp;</th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><em>Question</em></strong>:</td>
<td style="text-align:center">&nbsp;</td>
<td style="text-align:left">Which <strong>Red-Black Tree</strong> <a href="#Properties">properties</a> does the above case break?</td>
</tr>
<tr>
<td style="text-align:left">1. Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong></td>
<td style="text-align:center">&nbsp;</td>
<td style="text-align:left">We don’t break this because the new inserted node is colored as <strong>RED</strong></td>
</tr>
<tr>
<td style="text-align:left">2. All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong></td>
<td style="text-align:center">&nbsp;</td>
<td style="text-align:left">We don’t break this because the new inserted node is a nonempty node, it won’t impact the leaf nodes which are all nil(NULL Pointer) nodes</td>
</tr>
<tr>
<td style="text-align:left">3. Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes</td>
<td style="text-align:center">&nbsp;</td>
<td style="text-align:left">We don’t break this because the new inserted node is colored as <strong>RED</strong>, so the count of <strong>BLACK</strong> nodes should keep same as before</td>
</tr>
<tr>
<td style="text-align:left">4. Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes</td>
<td style="text-align:center">&nbsp;</td>
<td style="text-align:left"><strong>We might break property #4!!!</strong></td>
</tr>
<tr>
<td style="text-align:left">5. The root is always <strong>BLACK</strong></td>
<td style="text-align:center">&nbsp;</td>
<td style="text-align:left">We don’t break this because BST insertion will only insert the new node to the leaf nodes, the root node won’t be impacted</td>
</tr>
</tbody>
</table>
<p>So now we need to figure out a way to meet the property #4 in order to reconstruct the new BST to a <strong>Red-Black Tree</strong></p>
<p>The C++ code for <strong>Red-Black Tree Insertion</strong> is below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Red-Black Tree Insertion</span></div><div class="line"><span class="comment">// param : z, the node is going to be inserted </span></div><div class="line"><span class="comment">// return : root node</span></div><div class="line"><span class="function">Node *<span class="title">RB_Insert</span><span class="params">(Node *Root,Node * z)</span> </span>&#123; </div><div class="line">  Node * y=T_NIL;  </div><div class="line">  Node * x=Root;  </div><div class="line">  <span class="keyword">while</span>(x != T_NIL) &#123;               <span class="comment">// Find the proper place in T to insert the new node z, y will be the parent node</span></div><div class="line">    y=x;  </div><div class="line">    <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)  </div><div class="line">      x = x-&gt;left;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">      x = x-&gt;right;  </div><div class="line">  &#125;  </div><div class="line">  z-&gt;p = y;  </div><div class="line">  <span class="keyword">if</span> (y == T_NIL)                   <span class="comment">// Case 1: if y is nil, then set z as root</span></div><div class="line">    Root = z;  </div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)         <span class="comment">// Case 2: if z &lt; y, then set z as y's left child</span></div><div class="line">    y-&gt;left = z;  </div><div class="line">  <span class="keyword">else</span>                              <span class="comment">// Case 3: if z &gt;= y, then set z as y's right child</span></div><div class="line">    y-&gt;right = z;  </div><div class="line">  </div><div class="line">  z-&gt;left = T_NIL;                  <span class="comment">// Set z's left child as nil</span></div><div class="line">  z-&gt;right = T_NIL;                 <span class="comment">// Set z's right child as nil. So far done with BST insertion for the new node z</span></div><div class="line">  z-&gt;color = RED;                   <span class="comment">// Color z as RED</span></div><div class="line">  Root = RB_Insert_Fixup(Root,z);   <span class="comment">// Reconstruct(recolor or rotate) T via function RB_Insert_Fixup to meet all of the **Red-Black Tree** properties</span></div><div class="line">  <span class="keyword">return</span> Root;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The C++ code for <strong>Red-Black Tree RB_Insert_Fixup</strong> is below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node* <span class="title">RB_Insert_Fixup</span><span class="params">(Node *T,Node *z)</span>  </span>&#123;  </div><div class="line">  Node * y=<span class="literal">NULL</span>;  </div><div class="line">  <span class="keyword">while</span>(z-&gt;p-&gt;color == RED) &#123;    <span class="comment">// z's parent is RED breaks the property #4, so fix it!</span></div><div class="line">    <span class="keyword">if</span> (z-&gt;p == z-&gt;p-&gt;p-&gt;left) &#123; <span class="comment">// if z's parent is the left child of z's grampa</span></div><div class="line">      y = z-&gt;p-&gt;p-&gt;right;        <span class="comment">// set y as z's uncle (the right child of z's grampa)  </span></div><div class="line">      <span class="keyword">if</span> (y-&gt;color == RED) &#123;     <span class="comment">// Case 1: y (z's uncle) is RED</span></div><div class="line">        z-&gt;p-&gt;color = BLACK;     <span class="comment">// Case 1: set the color of z's parent as BLACK</span></div><div class="line">        y-&gt;color = BLACK;        <span class="comment">// Case 1: set the color of z's uncle as BLACK</span></div><div class="line">        z-&gt;p-&gt;p-&gt;color = RED;    <span class="comment">// Case 1: set z's grampa as RED</span></div><div class="line">        z = z-&gt;p-&gt;p;             <span class="comment">// Case 1: Iterate up, point z to z's grampa (the color of z is RED)  </span></div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z == z-&gt;p-&gt;right) &#123; <span class="comment">// Case 2: z's uncle is BLACK, and z is the right child of z's parent</span></div><div class="line">        z = z-&gt;p;                 <span class="comment">// Case 2: point z to z's parent</span></div><div class="line">        Left_Rotate(&amp;T,z);        <span class="comment">// Case 2: LEFT-ROTATE on z (z is the pivot)</span></div><div class="line">        z-&gt;p-&gt;color = BLACK;      <span class="comment">// Case 2 turns to Case 3: NOW z's uncle node is BLACK, and z is the left child of z's parent! Set z's parent as BLACK</span></div><div class="line">        z-&gt;p-&gt;p-&gt;color = RED;     <span class="comment">// Case 3: set z's grampa as RED</span></div><div class="line">        Right_Rotate(&amp;T,z-&gt;p-&gt;p); <span class="comment">// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// case 3: z's uncle is BLACK and z is the left child of z's parent</span></div><div class="line">        z-&gt;p-&gt;color = BLACK;     <span class="comment">// Case 3: set z's parent as BLACK</span></div><div class="line">        z-&gt;p-&gt;p-&gt;color = RED;    <span class="comment">// Case 3: set z's grampa as RED</span></div><div class="line">        Right_Rotate(&amp;T,z-&gt;p-&gt;p);<span class="comment">// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]</span></div><div class="line">      &#125; </div><div class="line">    &#125; <span class="keyword">else</span> &#123;                     <span class="comment">//Symmetric processing</span></div><div class="line">      y = z-&gt;p-&gt;p-&gt;left;  </div><div class="line">      <span class="keyword">if</span> (y-&gt;color == RED) &#123;     <span class="comment">// Case 1: z's uncle is RED</span></div><div class="line">        z-&gt;p-&gt;color = BLACK;  </div><div class="line">        y-&gt;color = BLACK;  </div><div class="line">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class="line">        z = z-&gt;p-&gt;p;  </div><div class="line">  	  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z == z-&gt;p-&gt;left) &#123; <span class="comment">// Case 2: z's uncle is BLACK and z is the left child of z's parent</span></div><div class="line">        z = z-&gt;p;  </div><div class="line">        Right_Rotate(&amp;T,z);  </div><div class="line">        z-&gt;p-&gt;color = BLACK;  </div><div class="line">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class="line">        Left_Rotate(&amp;T,z-&gt;p-&gt;p);   </div><div class="line">      &#125; <span class="keyword">else</span> &#123;                      <span class="comment">// Case 3: z's uncle is BLACK and z is the right child of z's parent</span></div><div class="line">        z-&gt;p-&gt;color = BLACK;  </div><div class="line">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class="line">        Left_Rotate(&amp;T,z-&gt;p-&gt;p);   </div><div class="line">      &#125;</div><div class="line">    &#125;  </div><div class="line">  &#125;    </div><div class="line">  T-&gt;color = BLACK;          <span class="comment">// make sure don't break the property #5, color the root as BLACK</span></div><div class="line">  <span class="keyword">return</span> T;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>According to <strong>z</strong>‘s <strong>parent</strong>‘s state, when we insert <strong>z</strong> into a <strong>Red-Black Tree</strong> and then color <strong>z</strong> as <strong>RED</strong>, there will be 3 cases to deal with:</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Case</strong></th>
<th style="text-align:center">&nbsp;</th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>1</strong>: <strong>z</strong> is the root node</td>
<td style="text-align:center">&nbsp;—&nbsp;</td>
<td style="text-align:left">Color node <strong>z</strong> as <strong>BLACK</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>2</strong>: <strong>z</strong>‘s <strong>parent</strong> is the root node</td>
<td style="text-align:center">&nbsp;—&nbsp;</td>
<td style="text-align:left">Do nothing, since <strong>T</strong> is still a <strong>Red-Black Tree</strong> after inserted <strong>z</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong>: <strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong></td>
<td style="text-align:center">&nbsp;—&nbsp;</td>
<td style="text-align:left">This case breaks the <a href="#Properties">property</a> #4, in this situation, <strong>z</strong> must have <strong>grampa</strong> node, further more</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:center">&nbsp;—&nbsp;</td>
<td style="text-align:left"><strong>z</strong> must have an <strong>uncle</strong> node (even it’s NIL, we will still say it exists and NIL node is <strong>BLACK</strong>).</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:center">&nbsp;—&nbsp;</td>
<td style="text-align:left">According to <strong>z</strong>‘s uncle’s state, we will have another <strong>3 sub-cases</strong> as below:</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Case</strong></th>
<th style="text-align:left">&nbsp;</th>
<th style="text-align:left">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>3.1</strong>:</td>
<td style="text-align:left"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>RED</strong></td>
<td style="text-align:left">(01) color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">(02) color <strong>z</strong>‘s uncle as <strong>BLACK</strong></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">(03) color <strong>z</strong>‘s grampa as <strong>RED</strong></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">(04) point <strong>z</strong> to <strong>z</strong>‘s grampa, then keep the processing iteratively</td>
</tr>
<tr>
<td style="text-align:left"><strong>3.2</strong>:</td>
<td style="text-align:left"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>,</td>
<td style="text-align:left">(01) point <strong>z</strong> to <strong>z</strong>‘s <strong>parent</strong></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">and <strong>z</strong> is the <strong>right child</strong> of <strong>z</strong>‘s <strong>parent</strong></td>
<td style="text-align:left">(02) <strong>LEFT-ROTATE</strong> on <strong>z</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>3.3</strong>:</td>
<td style="text-align:left"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>,</td>
<td style="text-align:left">(01) color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">and <strong>z</strong> is the <strong>left child</strong> of <strong>z</strong>‘s <strong>parent</strong></td>
<td style="text-align:left">(02) color <strong>z</strong>‘s grampa as <strong>RED</strong></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">(03) <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s grampa</td>
</tr>
</tbody>
</table>
<p><strong><em>The core idea about the 3 Sub-Cases above is : “Move the RED node to root, then color the root as BLACK”</em></strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>3.1</strong></th>
<th style="text-align:left">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>RED</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;&nbsp;<strong>z</strong> and <strong>z</strong>‘s <strong>parent</strong> are <strong>RED</strong>, it breaks <a href="#Properties">property</a> #4, so color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong> to resolve this problem.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Q</strong>:</td>
<td style="text-align:left">In this situation, <strong>z</strong> must have a <strong>BLACK grampa</strong>! <strong>Why?</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>A</strong>:</td>
<td style="text-align:left"><em>Check <strong><a href="#Properties">property</a> #4 and #5!</strong></em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">But when recolor <strong>z</strong>‘s <strong>parent</strong> from <strong>RED</strong> to <strong>BLACK</strong>, <a href="#Properties">property</a> #3 is broken, because the <strong>Black-Height</strong> of the subtree where <strong>z</strong>‘s <strong>parent</strong> exists increased by 1.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Q</strong>:</td>
<td style="text-align:left">How to resolve this problem?</td>
</tr>
<tr>
<td style="text-align:left"><strong>A</strong>:</td>
<td style="text-align:left"><em>Recolor <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong>, and recolor uncle from <strong>RED</strong> to <strong>BLACK</strong>.</em></td>
</tr>
<tr>
<td style="text-align:left"><strong>Q</strong>:</td>
<td style="text-align:left">Why this problem got resolved by this way?</td>
</tr>
<tr>
<td style="text-align:left"><strong>A</strong>:</td>
<td style="text-align:left"><em>Because the <strong>Black-Height</strong> of <strong>z</strong>‘s <strong>parent</strong> subtree increased by 1, means the <strong>Black-Height</strong> of <strong>z</strong>‘s <strong>grampa</strong> substree increased</em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"><em>by 1 as well, so recolor <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong> to resolve the problem that the <strong>Black-Height</strong> of <strong>grampa</strong> subtree increased</em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"><em>by 1, but it will introduce another problem that the <strong>Black-Height</strong> of <strong>uncle</strong> subtree decreased by 1, because in this case <strong>uncle</strong> is <strong>RED</strong>, so recolor <strong>uncle</strong> from <strong>RED</strong> to <strong>BLACK</strong> can resolve this problem.</em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"><em>According to the above steps: node <strong>z</strong>, <strong>z</strong>‘s <strong>parent</strong> and <strong>uncle</strong> will not violate the <strong>Red-Black Tree</strong> <a href="#Properties">property</a>, but <strong>z</strong>‘s <strong>grampa</strong> might violate!</em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"><em>If <strong>z</strong>‘s <strong>grampa</strong> is root, then color <strong>z</strong>‘s grampa as <strong>BLACK</strong> will resolve the problem completely.</em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"><em>If <strong>z</strong>‘s <strong>grampa</strong> is not root, then point the current node (pointer) to <strong>z</strong>‘s <strong>grampa</strong> as the <strong>“new” current node</strong>, then analyzes the <strong>“new” current node</strong></em></td>
</tr>
</tbody>
</table>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_1.jpg" alt="Red-Black Tree Intertion Case 1 " title="Red-Black Tree Intertion Case 1 "> 
<hr>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_1_full.jpg" alt="Red-Black Tree Intertion Case 1 another example " title="Red-Black Tree Intertion Case 1 another example "> 
<hr>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>3.2</strong></th>
<th style="text-align:left">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>, and <strong>z</strong> is the <strong>right child</strong> of <strong>z</strong>‘s <strong>parent</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;&nbsp;point <strong>z</strong> to <strong>z</strong>‘s <strong>parent</strong>, then <strong>LEFT-ROTATE</strong> on <strong>z</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Q</strong>:</td>
<td style="text-align:left"><strong>Why point z to z’s parent?</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>A</strong>:</td>
<td style="text-align:left"><em>Becase the new node will be always inserted as the leaf, so we should keep processing on the subtree ascend to the root to ensure satisfy with all of the <strong>Red-Black Tree</strong> <a href="#Properties">property</a></em></td>
</tr>
<tr>
<td style="text-align:left"><strong>Q</strong>:</td>
<td style="text-align:left"><strong>Why LEFT-ROTATE on z?</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>A</strong>:</td>
<td style="text-align:left"><em>The core idea of <strong>Red-Black Tree</strong> is “<strong>Move the RED node to root, then color the RED node to BLACK</strong>“”. Further more, because <strong>z</strong> is the <strong>right child</strong>, so we need <strong>LEFT-ROTATE</strong> to move <strong>z</strong> up!</em></td>
</tr>
</tbody>
</table>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_2.jpg" alt="Red-Black Tree Intertion Case 2 " title="Red-Black Tree Intertion Case 2 "> 
<hr>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_2_full.jpg" alt="Red-Black Tree Intertion Case 2 another example " title="Red-Black Tree Intertion Case 2 another example "> 
<hr>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>3.3</strong></th>
<th style="text-align:left">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>, and <strong>z</strong> is the <strong>left child</strong> of <strong>z</strong>‘s <strong>parent</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">&nbsp;&nbsp;recolor <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong>, recolor <strong>z</strong>‘s <strong>grampa</strong> as <strong>RED</strong>, then <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s <strong>grampa</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Q</strong>:</td>
<td style="text-align:left"><strong>Why recolor z and z’s parent?</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>A</strong>:</td>
<td style="text-align:left"><em>Both of the current node <strong>z</strong> and <strong>z</strong>‘s parent are <strong>RED</strong>, it breaks <a href="#Properties">property</a> #4, so recolor <strong>z</strong>‘s parent as <strong>BLACK</strong> to resolve this issue.</em></td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left">_After above step, <a href="#Properties">property</a> #3 is broken, because the <strong>Black-Height</strong> of the subtree where <strong>z</strong>‘s <strong>parent</strong> exists increased by 1__</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"><em>To resolve this problem, we need to recolor <strong>z</strong>‘s <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong>, and then do <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s <strong>grampa</strong>.</em></td>
</tr>
</tbody>
</table>
<img src="/archive/2016/11/16/Red-Black-Tree/rbt_insertion_case_3_full.jpg" alt="Red-Black Tree Intertion Case 3 another example " title="Red-Black Tree Intertion Case 3 another example "> 
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm" target="_blank" rel="external">http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm</a><br><a href="http://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/" target="_blank" rel="external">http://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/</a><br><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html" target="_blank" rel="external">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html</a><br><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html" target="_blank" rel="external">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://foursquarebehind.github.io/archive/2016/11/16/Red-Black-Tree/" data-id="civlf3grr00007clskotv4zxv" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/">Tree</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/archive/2016/11/15/Tree-Properties/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">Tree Properties</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/">Tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/">Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Math/" style="font-size: 10px;">Math</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Tree/" style="font-size: 20px;">Tree</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archive/2016/11/16/Red-Black-Tree/">Red-Black Tree</a>
          </li>
        
          <li>
            <a href="/archive/2016/11/15/Tree-Properties/">Tree Properties</a>
          </li>
        
          <li>
            <a href="/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/">Height of a Complete Binary Tree</a>
          </li>
        
          <li>
            <a href="/archive/2016/11/08/Most-Beautiful-Mathematical-Equations/">Most Beautiful Mathematical Equations</a>
          </li>
        
          <li>
            <a href="/archive/2016/10/24/Multiple-SSH-Keys-settings-for-different-github-account/">Multiple SSH Keys settings for different github account</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 bacon<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>